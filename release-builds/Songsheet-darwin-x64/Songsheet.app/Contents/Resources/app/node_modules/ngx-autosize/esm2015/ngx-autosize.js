import { ElementRef, HostListener, Directive, Input, NgModule } from '@angular/core';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const MAX_LOOKUP_RETRIES = 3;
class Autosize {
    /**
     * @param {?} element
     */
    constructor(element) {
        this.element = element;
        this.retries = 0;
        if (this.element.nativeElement.tagName !== 'TEXTAREA') {
            this._findNestedTextArea();
        }
        else {
            this.textAreaEl = this.element.nativeElement;
        }
    }
    /**
     * @param {?} textArea
     * @return {?}
     */
    onInput(textArea) {
        this.adjust();
    }
    /**
     * @return {?}
     */
    _findNestedTextArea() {
        this.textAreaEl = this.element.nativeElement.getElementsByTagName('TEXTAREA')[0];
        if (!this.textAreaEl) {
            if (this.retries >= MAX_LOOKUP_RETRIES) {
                console.warn('angular2-autosize: textarea not found');
            }
            else {
                this.retries++;
                setTimeout(() => {
                    this._findNestedTextArea();
                }, 100);
            }
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentChecked() {
        this.adjust();
    }
    /**
     * @return {?}
     */
    adjust() {
        if (this.textAreaEl) {
            let /** @type {?} */ clone = this.textAreaEl.cloneNode(true);
            let /** @type {?} */ parent = this.textAreaEl.parentElement;
            clone.style.visibility = 'hidden';
            parent.appendChild(clone);
            clone.style.overflow = 'hidden';
            clone.style.height = 'auto';
            let /** @type {?} */ lineHeight = this._getLineHeight();
            let /** @type {?} */ height = clone.scrollHeight;
            let /** @type {?} */ rowsCount = height / lineHeight;
            if (this.minRows && this.minRows >= rowsCount) {
                clone.style.overflow = 'auto';
                height = this.minRows * lineHeight;
            }
            else if (this.maxRows && this.maxRows <= rowsCount) {
                clone.style.overflow = 'auto';
                height = this.maxRows * lineHeight;
            }
            this.textAreaEl.style.height = height + 'px';
            parent.removeChild(clone);
        }
    }
    /**
     * @return {?}
     */
    _getLineHeight() {
        let /** @type {?} */ lineHeight = parseInt(this.textAreaEl.style.lineHeight, 10);
        if (isNaN(lineHeight)) {
            let /** @type {?} */ fontSize = window.getComputedStyle(this.textAreaEl, null).getPropertyValue('font-size');
            lineHeight = Math.floor(parseInt(fontSize.replace('px', '')) * 1.5);
        }
        return lineHeight;
    }
}
Autosize.decorators = [
    { type: Directive, args: [{
                selector: '[autosize]'
            },] },
];
/** @nocollapse */
Autosize.ctorParameters = () => [
    { type: ElementRef, },
];
Autosize.propDecorators = {
    "minRows": [{ type: Input },],
    "maxRows": [{ type: Input },],
    "onInput": [{ type: HostListener, args: ['input', ['$event.target'],] },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AutosizeModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return { ngModule: AutosizeModule, providers: [] };
    }
}
AutosizeModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    Autosize
                ],
                exports: [
                    Autosize
                ]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Generated bundle index. Do not edit.
 */

export { AutosizeModule, Autosize };
//# sourceMappingURL=ngx-autosize.js.map
